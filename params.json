{
  "name": "TaggedCoro 1.0.0",
  "tagline": "Tagged (nested) coroutines for Lua, implemented as a C module",
  "body": "[![Build Status](https://travis-ci.org/mascarenhas/taggedcoro.svg?branch=master)](https://travis-ci.org/mascarenhas/taggedcoro)\r\n[![Coverage Status](https://coveralls.io/repos/github/mascarenhas/taggedcoro/badge.svg?branch=master)](https://coveralls.io/github/mascarenhas/taggedcoro?branch=master)\r\n\r\n## Overview\r\n\r\nThis module is is a replacement to the standard `coroutine`\r\nmodule that adds *tagged* coroutines. Functions `create`\r\nand `wrap` now receive a *tag* and a function, instead\r\nof just a function. Function *yield* now also needs a\r\ntag as the first argument. The tag can be any Lua value.\r\n\r\nA `yield` with a specific tag yields to the dynamically\r\nclosest `resume` of a coroutine with that tag (making\r\nan analogy with exceptions: the coroutine is like\r\na try/catch block, `yield` is like a throw,\r\nand the tag is analogous with the type of the exception).\r\nIf there is no coroutine with the tag an error is thrown\r\nat the point of the `yield`.\r\n\r\nOn a successful yield, any coroutine that has been passed\r\nthrough in the search for the coroutine that handled that\r\nyield becomes `stacked`, a new status string returned\r\nby the `status` function. Attempting to directly resume a\r\nstacked coroutine is an error. Resuming the coroutine that\r\nhandled the yield rewinds the whole stack, resuming the\r\nstacked coroutines along the way until reaching and finally\r\ncontinuing from the point of the original yield.\r\n\r\nA failed yield can be an expensive operation, so if you are\r\nunsure if you can yield you can use the extended `isyieldable`\r\nfunction, which now expects a tag and will return `true`\r\nonly if yielding with this tag will succeed.\r\n\r\nThe function `coroutine.yield` is an *untagged* yield. A tagged\r\ncoroutine passes an untagged yield along, unless its parent\r\nis the main coroutine: in this case, the yield is supressed, and\r\nthe source resumes from the untagged yield with the call to yield\r\nreturning `nil` and `\"untagged coroutine not found\"`. Unfortunately\r\nthere is no way to make the untagged yield fail as if it had tried\r\nto yield outside a coroutine.\r\n\r\nWhen an untagged yield reaches an untagged parent, the parent will\r\nsuspend as if the yield was intended for it; when the parent\r\nresumes the whole stack will be resumed, ultimately resuming\r\nfrom the point of the untagged yield. This way you can\r\nhave a stack of tagged coroutines on top of an untagged coroutine\r\n(allowing the use of existing coroutine schedulers, for example).\r\n\r\nA tagged yield that reaches an untagged coroutine fails at the\r\npoint of the call to `yield` as if it had reached the main coroutine.\r\n\r\nA new function `call` resumes a coroutine as if it had been\r\n*wrapped* by `wrap`: any uncaught errors while running the\r\ncoroutine will be propagated. But the stack is not unwound:\r\nyou can still get a traceback of the full stack of the dead coroutine\r\n(including all of the coroutines that were stacked above it) using\r\nthe new `traceback` function. It is similar to `debug.traceback`,\r\nexcept that it includes a full traceback, following `source` to\r\nreach the source of the error and tracing `parent` back to the main\r\nthread.\r\n\r\nA new `tag` function returns the tag of a coroutine. A `parent`\r\nfunction returns the coroutine that last resumed a coroutine.\r\nA `source` function returns, for a given coroutine,\r\neither the coroutine where the last `yield` came from,\r\nin case of a `suspended` coroutine, or\r\nwhere an error originated, in case of a `dead` coroutine. You can\r\nuse these two functions to walk a `dead` stack of coroutines\r\nwith the `debug` functions in case `traceback` is not enough.\r\n\r\nFinally, the function `fortag` receives a tag and returns a\r\nset of tagged coroutine functions specialized for that tag.\r\nFor compatibility with [lua-coronest](https://github.com/saucisson/lua-coronest)\r\nthere is also a `make` function that is like `fortag` except it\r\ngenerates a fresh tag if none is given.\r\n\r\nThere is both a C and a pure Lua implementation. The C\r\nimplementation is more efficient, and produces better\r\nstacktraces, but requires stock Lua 5.2 or higher (it\r\nwill not work with LuaJIT 2). The pure Lua implementation\r\nshould work on LuaJIT 2, Lua 5.2, or Lua 5.3,\r\nbut the `isyieldable` might give a false positive if\r\nthere are pending unyieldable C calls in the stack on any\r\nLua version except Lua 5.3.\r\n\r\n## Installation\r\n\r\nGet the latest release of the C module from [LuaRocks](http://luarocks.org):\r\n\r\n    luarocks install taggedcoro\r\n\r\nOr if you want the pure Lua version:\r\n\r\n    luarocks install taggedcoro-purelua\r\n\r\nIf you want to install from HEAD, download a tarball/zip of\r\nthis repository or clone it, then run `luarocks make` on one of\r\nthe provided rockspecs.\r\n\r\nThe C module is compatible with both Lua 5.2 and Lua 5.3. The\r\nLua module is compatible with LuaJIT 2, Lua 5.2, and Lua 5.3.\r\n\r\n## Module reference\r\n\r\nAll the functions below are exported by the module.\r\n\r\n### create(tag, f)\r\n\r\nCreates a new tagged coroutine, with tag `tag` (any Lua value except `nil`) and body `f` (must be a function).\r\nReturns this new coroutine. Like the standard `coroutine` library, a coroutine is an object with type \"thread\".\r\n\r\n### isyieldable(tag)\r\n\r\nReturns `true` when a yield with tag `tag` will not fail, otherwise it will return false.\r\n\r\n### resume(co, ...)\r\n\r\nStarts or continues the execution of the tagged coroutine `co`. It works just like [`coroutine.resume`](https://www.lua.org/manual/5.3/manual.html#pdf-coroutine.resume). \r\n\r\n### call(co, ...)\r\n\r\nStarts or continues the execution of the tagged coroutine `co`, but any errors are propagated, and the\r\ninitial boolean is not returned in case of success (either because the coroutine yielded or it finished\r\nrunning). The source of the error is still recorded (see `source` below) so the stack can be inspected\r\nlater.\r\n\r\n### running()\r\n\r\nReturns the running coroutine plus a boolean, true when the running coroutine is the main one.\r\n\r\n### status(co)\r\n\r\nReturns the status of the (tagged or not) coroutine `co`, as a string. Returns the same status strings\r\nas [`coroutine.status`](https://www.lua.org/manual/5.3/manual.html#pdf-coroutine.status), plus a new one\r\nfor tagged coroutines: \"stacked\". A coroutine is \"stacked\" if it has been suspended by a yield but is\r\nnot the coroutine that handled that yield (because of a different tag). A \"stacked\" coroutine cannot\r\nbe resumed directly.\r\n\r\n### wrap(co) or wrap(tag, f)\r\n\r\nIf called with a tagged coroutine, returns a function that calls `call` on this coroutine\r\nplus any arguments to the function. If called with a tag `tag` and a function `f`, creates\r\na new coroutine and then returns both a function that calls `call` on this coroutine\r\nand the coroutine itself.\r\n\r\n### yield(tag, ...)\r\n\r\nSuspends the execution of the nearest coroutine with the tag `tag` (tag equality is checked with `==`, not `rawequal`).\r\nAny arguments to yield are returned by the `resume` or `call` call that last resumed this coroutine. Any interving\r\ncoroutines are *stacked* (see `status`, above).\r\n\r\nIf there is no coroutine with a matching tag `yield` throws an error *at the point of its call*. It\r\nwill also throw an error at the point of the call if yielding failed because of non-yieldable\r\nC functions. \r\n\r\n### tag(co)\r\n\r\nReturns the tag associated with the tagged coroutine `co`, or `nil` if `co` is an untagged coroutine.\r\n\r\n### parent(co)\r\n\r\nReturns the coroutine that last resumed the tagged coroutine `co` (through either `resume` or `call`).\r\nReturns `nil` if `co` is an untagged coroutine, or if the coroutine has been created but not started yet.\r\n\r\n### source(co)\r\n\r\nIf the tagged coroutine `co` is suspended, returns the tagged coroutine that called `yield`. If `co`\r\nis dead due to an error, returns the tagged coroutine where the error originated. If `co` is running\r\nbut caught an error in another coroutine (through `resume`, `pcall`, or `xpcall`), `source` also\r\nreturns the tagged coroutine where the error originated. Returns `nil` in\r\nall other cases (including if `co` is an untagged coroutine).\r\n\r\nYou can use `source` and `parent` to walk the stack (using the `debug` functions) after an error occurs.\r\nThe `traceback` function below uses this to construct a full traceback string analogous to the traceback returned\r\nby `debug.traceback` but for the full coroutine stack, starting from the coroutine that originated the error.\r\n\r\n### traceback([co,] [message [, level]])\r\n\r\nIf the first argument is a coroutine, uses the `source` (see above) of this coroutine as the start\r\nof the traceback, otherwise uses the `source`  of the running coroutine as the start. The traceback\r\nends after tracing the main coroutine (or after tracing an untagged coroutine; in this case there will\r\nbe a message indicating this in the traceback). If a message is present it is appended to the beginning\r\nof the traceback. An optional level number tells at which level to start the traceback, on the starting\r\ncoroutine (default is 1, the top of the call stack). Returns a string with a traceback of the call stack\r\nof all coroutines from the starting one, using `parent` to trace back from it.\r\n\r\n### fortag(tag)\r\n\r\nReturns a table containing all of the functions above (except `fortag` itself), with the four functions\r\nthat expect a tag (`create`, `wrap`, `yield`, and `isyieldable`) specialized for the tag `tag` (the signatures\r\nof these functions do not have a `tag` parameter).\r\n\r\n### make([tag])\r\n\r\nLike `fortag`, but generates a fresh tag (an new empty table) if none is given.\r\n\r\n### install() - *Lua 5.2 and Lua 5.3 only*\r\n\r\nInstalls a metatable for all coroutines (tagged and untagged, because all coroutines must share a single metatable).\r\nAfter installing this metatable every coroutine has `resume`, `call`, `status`, `tag`, `parent`, and `source` as methods.\r\nEvery coroutine can also be called as if it were a function, with the same effect as its `call` method. Returns the\r\nmodule (so you can both require the module and install the metatable in one step: `local tc = require(\"taggedcoro\").install()`).\r\n\r\n## Extras\r\n\r\nThe `contrib` folder has sample libraries\r\nthat implement some abstractions on top of coroutines that\r\ncan be freely composed with tagged coroutines. The\r\n`samples` folder has sample scripts that exercise\r\nthese higher-level libraries. Some of them depend on\r\nthe [thread](https://github.com/mascarenhas/thread)\r\nlibrary and on a branch of [Cosmo](https://github.com/mascarenhas/cosmo/tree/taggedcoro)\r\nthat requires tagged coroutines.\r\n\r\n## Contact\r\n\r\nPlease open an issue on [github](http://github.com/mascarenhas/taggedcoro) if you would\r\nlike to report any bugs, or suggest improvements.\r\n\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}
{
  "name": "TaggedCoro",
  "tagline": "Tagged (nested) coroutines for Lua, implemented as a C module",
  "body": "# Tagged Coroutines 1.0.0\r\n\r\nThis module is is a replacement to the standard `coroutine`\r\nmodule that adds *tagged* coroutines. Functions `create`\r\nand `wrap` now receive a *tag* and a function, instead\r\nof just a function. Function *yield* now also needs a\r\ntag as the first argument. The tag can be any Lua value.\r\n\r\nA yield with a specific tag yields to the dynamically\r\nclosest resume of a coroutine with that tag (making\r\nan analogy with exceptions: the coroutine is like\r\na try/catch block, yield is like a throw,\r\nand the tag is analogous with the type of the exception).\r\nIf there is no coroutine with the tag an error is thrown\r\nat the point of the yield.\r\n\r\nOn a successful yield, any coroutine that has been passed\r\nthrough in the search for the coroutine that handled that\r\nyield becomes `stacked`, a new status string returned\r\nby the `status` function. Attempting to directly resume a\r\nstacked coroutine is an error. Resuming the coroutine that\r\nhandled the yield rewinds the whole stack, resuming the\r\nstacked coroutines along the way until reaching and finally\r\ncontinuing from the point of the original yield.\r\n\r\nA failed yield is an expensive operation, so if you are\r\nunsure if you can yield you can use the extended `isyieldable`\r\nfunction, which now expects a tag and will return `true`\r\nonly if yielding with this tag will succeed.\r\n\r\nA new function `call` resumes a coroutine as if it had been\r\n*wrapped* by `wrap`: any uncaught errors while running the\r\ncoroutine will be propagated. But the stack is not unwound:\r\nyou can still get a traceback of the full stack of the dead coroutine\r\n(including all of the coroutines that were stacked above it) using\r\nthe new `traceback` function. It is similar to `debug.traceback`,\r\nexcept that it includes any stacked coroutines in the traceback.\r\n\r\nA new `tag` function returns the tag of a coroutine. A `parent`\r\nfunction returns the coroutine that last resumed a coroutine.\r\nA `source` function returns, for a given coroutine,\r\neither the coroutine where the last `yield` came from,\r\nin case of a `suspended` coroutine, or\r\nwhere an error originated, in case of a `dead` coroutine. You can\r\nuse these two functions to walk a `dead` stack of coroutines\r\nwith the `debug` functions in case `traceback` is not enough.\r\n\r\nFinally, the function `fortag` receives a tag and returns a\r\nset of tagged coroutine functions specialized for that tag.\r\nFor compatibility with [lua-coronest](https://github.com/saucisson/lua-coronest)\r\nthere is also a `make` function that is like `fortag` except it\r\ngenerates a fresh tag if none is given.\r\n\r\nInstall it by running `luarocks make` on the provided\r\nrockspec file. The `contrib` folder has sample libraries\r\nthat implement some abstractions on top of coroutines that\r\ncan be freely composed with tagged coroutines. The\r\n`samples` folder has sample scripts that exercise\r\nthese higher-level libraries. Some of them depend on\r\nthe [thread](https://github.com/mascarenhas/thread)\r\nlibrary and on a branch of [Cosmo](https://github.com/mascarenhas/cosmo/tree/taggedcoro)\r\nthat requires tagged coroutines.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}